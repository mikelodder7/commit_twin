<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.5.1/katex.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/github-markdown-css/2.2.1/github-markdown.css"/>

# Commit Twin
Create a zero-knowledge equality proof from two commitments.

This project demonstrates how to create a zero-knowledge proof that two commitments hide the same secret using elliptic curves.

This project has two implementations: golang and rust.

## Primitives

The protocol uses any elliptic curve.

The curve <img src="https://render.githubusercontent.com/render/math?math=E"> parameters are denoted as

- <img src="https://render.githubusercontent.com/render/math?math=k">: The security parameter in bits.
- <img src="https://render.githubusercontent.com/render/math?math=p">: The field modulus
- <img src="https://render.githubusercontent.com/render/math?math=q">: The subgroup order
- <img src="https://render.githubusercontent.com/render/math?math=H_q">: A hash function which outputs bytes less than <img src="https://render.githubusercontent.com/render/math?math=q^1">.
- <img src="https://render.githubusercontent.com/render/math?math=G">: Points in the cyclic group of order <img src="https://render.githubusercontent.com/render/math?math=p">
- <img src="https://render.githubusercontent.com/render/math?math=P">: The base point in <img src="https://render.githubusercontent.com/render/math?math=G">
- <img src="https://render.githubusercontent.com/render/math?math=Q_1">: A point in <img src="https://render.githubusercontent.com/render/math?math=G"> whose discrete log is not known or relative to <img src="https://render.githubusercontent.com/render/math?math=P^{2}">
- <img src="https://render.githubusercontent.com/render/math?math=Q_2">: A point in <img src="https://render.githubusercontent.com/render/math?math=G"> whose discrete log is not known or relative to <img src="https://render.githubusercontent.com/render/math?math=P^{2}">
- <img src="https://render.githubusercontent.com/render/math?math=1_G">: The point at infinity

Scalars operate in <img src="https://render.githubusercontent.com/render/math?math=\mathbb{Z}_q"> and are denoted as lower case letters.

Points operating in <img src="https://render.githubusercontent.com/render/math?math=G"> are denoted as capital letters. 


<img src="https://render.githubusercontent.com/render/math?math=^1"> A common approach is to use SHA256 to hash to byte sequence then reduce modulo <img src="https://render.githubusercontent.com/render/math?math=q">. However, this results in a biased result that isn't uniform. Instead more bytes should be generated then reduced modulo <img src="https://render.githubusercontent.com/render/math?math=q">. The number of bytes is calculated with L = ceil((ceil(log2(p)) + k) / 8).

<img src="https://render.githubusercontent.com/render/math?math=^2"> Consider this when choosing <img src="https://render.githubusercontent.com/render/math?math=Q_1">, <img src="https://render.githubusercontent.com/render/math?math=Q_2"> from [Appendix A](https://datatracker.ietf.org/doc/draft-irtf-cfrg-hash-to-curve/) The problem of mapping arbitrary bit strings to elliptic curve points has been the subject of both practical and theoretical research. This section briefly describes the background and research results that underly the recommendations in this document.  A naive but generally insecure method of mapping a string msg to a point on an elliptic curve <img src="https://render.githubusercontent.com/render/math?math=E"> having <img src="https://render.githubusercontent.com/render/math?math=p"> points is to first fix a point <img src="https://render.githubusercontent.com/render/math?math=P"> that generates the elliptic curve group, and a hash function Hp from bit strings to integers less than <img src="https://render.githubusercontent.com/render/math?math=p">; then compute <img src="https://render.githubusercontent.com/render/math?math=Hp(msg)\cdot P">, where the <img src="https://render.githubusercontent.com/render/math?math=\cdot"> operator represents scalar multiplication.  The reason this approach is insecure is that the resulting point has a known discrete log relationship to <img src="https://render.githubusercontent.com/render/math?math=P">.  Thus, except in cases where this method is specified by the protocol, it must not be used; doing so risks catastrophic security failures.
   
Also, <img src="https://render.githubusercontent.com/render/math?math=Q_1">, <img src="https://render.githubusercontent.com/render/math?math=Q_2"> should not be generated by randomly choosing a scalar <img src="https://render.githubusercontent.com/render/math?math=r"> and computing <img src="https://render.githubusercontent.com/render/math?math=r \cdot P">. The best method to choose <img src="https://render.githubusercontent.com/render/math?math=Q_1">, <img src="https://render.githubusercontent.com/render/math?math=Q_2"> is to pick a nothing up my sleeve value and compute the hash to curve of the bit string.

If using pairing friendly curves this same protocol can be used to compare commitments in <img src="https://render.githubusercontent.com/render/math?math=G_1"> and <img src="https://render.githubusercontent.com/render/math?math=G_2">.

## Setup

Alice secretly holds <img src="https://render.githubusercontent.com/render/math?math=x \in \mathbb{Z}_q*"> and randomly chooses <img src="https://render.githubusercontent.com/render/math?math=r_1, r_2 \in \mathbb{Z}_q*"> in order to compute two commitments <img src="https://render.githubusercontent.com/render/math?math=B = x \cdot P %2B r_1 \cdot Q_1"> and <img src="https://render.githubusercontent.com/render/math?math=C = x \cdot P %2B r_2 \cdot Q_2">.

Bob knows <img src="https://render.githubusercontent.com/render/math?math=B, C"> but doesn't know <img src="https://render.githubusercontent.com/render/math?math=x, r_1, r_2">.

## Protocol

- Bob sends nonce <img src="https://render.githubusercontent.com/render/math?math=o \in Z_q*"> to Alice
- Alice picks random <img src="https://render.githubusercontent.com/render/math?math=w, n_1, n_2 \in \mathbb{Z}_q*">.
- She computes <img src="https://render.githubusercontent.com/render/math?math=W_1 = w \cdot P %2B n_1 \cdot Q_1"> and <img src="https://render.githubusercontent.com/render/math?math=W_2 = w \cdot P %2B n_2 \cdot Q_2">.
- She computes <img src="https://render.githubusercontent.com/render/math?math=c = H_q(W_1\ ||\ W_2\ ||\ o)">
- She computes <img src="https://render.githubusercontent.com/render/math?math=d = w - cx, d_1 = n_1 - c r_1, d_2 = n_2 - c r_2"> all in <img src="https://render.githubusercontent.com/render/math?math=\mathbb{Z}_q*">
- Alice sends <img src="https://render.githubusercontent.com/render/math?math=\{c, d, d_1, d_2\}"> to Bob.
- Bob computes <img src="https://render.githubusercontent.com/render/math?math=D = d \cdot P">
- Bob checks that <img src="https://render.githubusercontent.com/render/math?math=c \overset{?}{=} H_q(D %2B d_1 \cdot Q_1 %2B c \cdot B\ ||\ D %2B d_2 \cdot Q_2 %2B c \cdot C\ ||\ o)">

### Note

The commitment <img src="https://render.githubusercontent.com/render/math?math=C$"> doesn't have to use <img src="https://render.githubusercontent.com/render/math?math=x \cdot P"> but could be another point like <img src="https://render.githubusercontent.com/render/math?math=P_1">. The protocol will still work.

<img src="https://render.githubusercontent.com/render/math?math=o"> can also be a nothing up my sleeve value chosen by Alice as long as its not used more than once like a timestamp in milliseconds in which case Bob doesn't need to send it Alice.
The security concern is that Alice should not be able to pick a value that allows her to cheat in the proof by biasing the result.

If Bob knows <img src="https://render.githubusercontent.com/render/math?math=B"> but not <img src="https://render.githubusercontent.com/render/math?math=C">, then <img src="https://render.githubusercontent.com/render/math?math=C"> could also be part of the proof and sent.